# datetime
```python
import datetime
# 날짜 배정
day1 = datetime.date(2021,12,24)
day2 = datetime.date(2023,4,5)

# 빼기 연산으로 쉽게 차 구하기 가능
diff = day2-day1 # timedelta 객체를 반환

# 실제 날을 출력할 때는 days 에 접근
print(diff.days)
# weekday 함수로 요일 계산 가능
print(diff.weekday) #1 (요일을 숫자로 리턴. 0월 1화)
print(diff.isoweekday) #1 (요일을 숫자로 리턴. 1 을 월요일로)
```

# time
## time.time
- UTC 기반 현재시각 

## time.localtime
- time.localtime(time.time)
- 위 형태로, 타임을 변환하는 함수
```python
time.struct_time(tm_year=2023,tm_mon=5,tm_mday=21.tm_hour=16,tm_min=48,tm_sec=42,tm_wday=1, tm_yday=141,tm_isdst=0)
```

## time.asctime
```python
# 3단 변환
time.asctime(time.localtime(time.time()))
# 아래처럼 알아보기 쉬운 사람이 읽을만한 날짜로 나온다.
'Fri Apr 28 20:50:20 2023'

# 현재시각만을 출력하려면 ctime 으로도 충분
time.ctime()
'Fri Apr 28 20:56:31 2023'
```

time.strftime
- time.strftime('format 코드', time.localtime(time.time) )
```
포맷코드 설명 예
%a 요일의 줄임말 Mon
%A 요일 Monday
%b 달의 줄임말 Jan
%B 달 January
%c 날짜와 시간을 출력함. Thu May 25 10:13:52 2023
%d 일 (day) [01,31]
%H 시간 (hour): 24 시간 출력 형태 [00,23]
%I 시간 (hour): 12 시간 출력 형태 [01,12]
%j 1 년 중 누적 날짜 [001,366]
%m 달 [01,12]
%M 분 [01,59]
%p AM or PM AM
%S 초 [00,59]
%U 1 년 중 누적 주 (일요일 시작) [00,53]
%w 숫자로 된 요일 [0(일), 6(토)]
%W 1 년 중 누적 주 (월요일 시작) [00,53]
%x 현재 설정된 지역에 기반한 날짜 출력 05/25/23
%X 현재 설정된 지역에 기반한 시간 출력 17:22:21
```
```python
import time
time.strftime('%x', time.localtime(time.time()))
'05/25/23'
time.strftime('%c', time.localtime(time.time()))
'Thu May 25 10:13:52 2023'
```

## time.sleep
- 초 단위로 멈춘다.

# math
## math.gcd(*int)
- 최대 공약수
- 3.9버전부터는 여러 int 를 받을 수 있고, 그 이전엔 2개만.

## math.lcm(*int)
- 최소 공배수
- 3.9버전부터 사용 가능. 

# random
```python
# 랜덤 모듈
import random

# 랜덤 함수는 0.0~1.0 사이의 실수를 반환
random.random()

# randint 는 아예 정수 반환을 위해 존재하는 개별 함수.
random.randint(1,10)

# random.choice 는 받은 리스트에서 하나를 랜덤으로 반환함(리스트에서 삭제는 안함)
random.choice
```
# itertools
## zip_longhest(*iterables, fillvalue=None)
- zip 과 똑같이 작동.
- 그러나, 가장 긴 쪽에 맞춰 뭔가 채워줌
## permutations(iterable, r)
- iterable 에서 r 개를 선택한 순열을 리턴
```python
import itertools
list(itertools.permutations(['1', '2', '3'], 2))
# [('1', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('3', '1'), ('3', '2')
```
## combinations(iterable, r)
- iterable 에서 r 개를 선택한 조합을 리턴

# functools
## reduce(function, iterable)
- iterable 의 왼쪽에서 오른쪽으로 2개씩 뽑아가며 function을 적용해 하나로 줄인다.
```python
 # reduce_test.py
 import functools
 data = [1, 2, 3, 4, 5]
 result = functools.reduce(lambda x, y: x + y, data)
 print(result) # 15 출력
```

# operator
## itemgetter
- sorted의 매개변수 등으로 활용해, 정렬의 기준을 세워준다.
```python
 #itemgetter1.py
 fromoperator import itemgetter
 students=[
 ("jane",22, 'A'),
 ("dave",32, 'B'),
 ("sally",17,'B'),
 ]
 # 튜플 인덱스 1번, 나이를 기준으로 정렬하도록 지시.
 result =sorted(students,key=itemgetter(1))
 print(result)
```
```python
#itemgetter2.py
 fromoperator import itemgetter
 students=[
 {"name": "jane", "age":22, "grade": 'A'},
 {"name": "dave", "age":32, "grade": 'B'},
 {"name": "sally", "age":17, "grade": 'B'},
 ]
 # 딕셔너리의 두 번째 키, age 기준으로 정렬하도록 지시.
 result =sorted(students,key=itemgetter('age'))
 print(result)
```
## attrgetter
- 튜플이나 딕셔너리가 아닌 클래스의 정렬에 사용.
```python
 # attrgetter1.py
 from operator import attrgetter

 class Student:
    def __init__(self, name, age, grade):
    self.name = name
    self.age = age
    self.grade = grade

students = [
    Student('jane', 22, 'A'),
    Student('dave', 32, 'B'),
    Student('sally', 17, 'B'),
]
result = sorted(students, key=attrgetter('age')
```

# shutil
- shell 을 조작하는 모듈
- 파일의 copy, move 등에 쓸 수 있다.
```python
 # shutil_copy.py
import shutil
shutil.copy("c:/doit/a.txt", "c:/temp/a.txt.bak")
shutil.move("c:/doit/a.txt", "c:/temp/a.txt")
```

# glob
- 특정 디렉터리의 파일 정보 전부를 반환.
```python
import glob

# 해당 폴더 내에 존재하는 모든 파일명을 리스트로 반환.
glob.glob("c:/doit/mark*")
# ['c:/doit\\marks1.py', 'c:/doit\\marks2.py', 'c:/doit\\marks3.py']
```

# pickle
- 피클처럼 절여서 저장하기 위한 것. 
- 파일로 영구화해 파이썬 객체를 그대로 보존한다.
```python
import pickle
# 저장시엔 파일 객체가 필요하다.
f = open("test.txt", 'wb')
data = {1:'python', 2:'you need'}
pickle.dump(data,f)
f.close

# dump로 저장했다면 load 로 로드한다.
f = open("test.txt",'rb')
data = pickle.load(f)
```
# os
- 환경변수, 디렉터리, 파일 등의 os 자원에 접근하게 해준다.

## environ
- 환경변수들의 목록을 딕셔너리 형태로 구성된 environ 객체로 반환.
- 딕셔너리처럼 키 접근법으로 접근 가능
- os.envirion["PATH"]
```python
import os
os.environ
environ({'PROGRAMFILES': 'C:\\Program Files', 'APPDATA': ⋯ 생 략 ⋯})
```

## chdir(path: str)
- 현재 디렉터리 위치를 바꿀 수 있음
## getcwd
- 현재 디렉터리를 반환

## system(command:str)
- 실제 시스템 명령어를 호출 가능
- os.system("dir")

## popen
- 실행한 시스템 명령어의 결과값을 파일 형태로 읽는다.
```python
f = os.popen("dir")
print(f.read())
```

# threading
- 멀티스레딩 관련.
```python
#싱글스레드 예시
import time
def long_task(): # 5초의 시간이 걸리는 함수
    for i in range(5):
    time.sleep(1) # 1초간 대기한다.
    print("working:%s\n" % i)

print("Start")

for i inrange(5): # long_task를5회수행한다.
    long_task()

print("End")
```
```python
#thread_test.py
import time
import threading #스레드를생성하기위해서는threading모듈이필요하다.
def long_task():
    for iin range(5):
    time.sleep(1)
    print("working:%s\n" % i)

print("Start")

threads =[]
for i inrange(5):
    t = threading.Thread(target=long_task) #스레드를생성한다.
    threads.append(t)

for t in threads:
t.start() #스레드를실행한다.

for t in threads:
    t.join() # join으로 스레드가 종료될때까지 기다린다.

print("End")
```

# json
## load(f:file)
- json 파일을 딕셔너리로 변환.
## dump(data:dict, f:file)

## loads(json: str)
- json '문자열' 을 딕셔너리로 변환
## dumps(data: dict)
- 딕셔너리를 json 문자열로 변환.
- ensure_ascii=False 아스키로 변환하지 않아 한글 유지
- indent(int) 들여쓰기해줌


# urllib
```python
import urllib.request
def get_wikidocs(page):
    resource = 'http://wikidocs.net/{}'.format(page)
    # 인터넷으로 접속 가능한 문서를 파일처럼 다룰 수 있다.
    with urllib.request.urlopen(resource) as s:
        with open('wikidocs_%s.html' % page, 'wb') as f:
            f.write(s.read())
```