# re모듈
```python
# re 모듈이 regular expression 담당 모듈
import re
# 컴파일 함수를 통해 패턴 객체를 만든다.
p = re.compile('ab*')
```
## 패턴 객체
이하의 메서드들을 제공한다.
- match : 문자열의 처음부터 정규식과 매칭되는지 조사. (매칭시 매칭객체, 아닐시 None 반환)
- search : 문자열 전체를 검색해 정규식과 매칭되는지 조사한다. (매칭시 매칭객체, 아닐시 None 반환)
- findall : 정규식과 매칭되는 모든 문자열을 리스트로 반환
- finditer : 정규식과 매칭되는 모든 문자열을 이터레이터 형태로 반환

### match 의 예시
```python
import re
# 문자열 하나 이상의 패턴을 컴파일
p = re.compile('[a-z]+')

# 패턴이 매칭되는지 확인한다
m = p.match("python")
print(m)
# <re.Match object; span=(0, 6), match='python'>

m = p.match("3 python")
print(m)
# None 
# 매치는 문자열 전체를 앞에서부터 매칭하므로, 숫자가 들어있으면 뒷쪽 패턴이 문자열이어도 매칭되지 않음.
```

### search 의 예시
```python
import re
# 문자열 하나 이상의 패턴을 컴파일
p = re.compile('[a-z]+')

# 이번에는 search 로 시도
m = p.search("3 python")
print(m)
# <re.Match object; span=(2, 8), match='python'>
# 서치는 처음부터 매칭 시도하는게 아니라 문자열 전체를 대상으로 어딘가 한군데만 맞아도 매칭한다.
```

### findall 의 예시
```python
import re
# 문자열 하나 이상의 패턴을 컴파일
p = re.compile('[a-z]+')

# findall 로 새 문자열을 매칭해봄
result = p.findall("life is too short")
print(result)
# ['life', 'is', 'too', 'short']
# 파인드올은 패턴과 매칭되는 모든 문자열을 리스트로 쪼갠다.
```

### finditer 의 예시
```python
import re
# 문자열 하나 이상의 패턴을 컴파일
p = re.compile('[a-z]+')

# findall 로 새 문자열을 매칭해봄
result = p.finditer("life is too short")

print(result)
# <callable_iterator object at 0x01F5E390>

for r in result:
    print(r)
#<re.Match object; span=(0, 4), match='life'>
#<re.Match object; span=(5, 7), match='is'>
#<re.Match object; span=(8, 11), match='too'>
#<re.Match object; span=(12, 17), match='short'>
```
## match 객체
이하의 메서드들을 제공한다.
- group : 매치된 문자열을 반환
- start : 매치된 문자열의 시작 위치를 반환
- end : 매치된 문자열의 끝 위치를 반환
- span : 매치된 문자열의 (시작, 끝) 위치를 튜플로 반환
```python
m = p.match('python')

m.group()
# 'python'

m.start()
# 0

m.end()
# 6

m.span()
# (0,6)
```

## 축약 표현법
```python
# 컴파일을 하지 말고, 모듈에서 직접 (표현식,문자) 형태로 인자를 주면 즉시 처리가능.
# 한번 컴파일된 정규표현식을 재사용할 생각이 아니라면, 이렇게 빠르게 처리해도 좋다.
m = re.match('[a-z]+',"python")
```

## 컴파일 옵션
- DOTALL(S) : . 이 '줄바꿈 문자 \n 를 포함'한 모든 문자와 매칭되도록 한다. 디폴트는 줄바꿈 문자 제외한 모든 문자다.
- IGNORECASES(I) : 대소문자와 관계 없이 매칭한다.
- MULTILINE(M) : 여러 줄과 매칭되도록 한다. ^,$ 메타문자 사용과 관련있다.
- VERVOSE(V) : 정규식을 보기 편하게 하고 주석을 쓸 수 있다.
- re.DOTALL / re.S 로 풀문자 / 약어 중 어느 쪽을 써도 사용가능.

### 멀티라인의 예시
```python
# MULTILINE 의 예시
# multiline.py
import re

p = re.compile("^python\s\w+", re.MULTILINE)

data = """python one
life is too short
python two
you need python
python three"""

print(p.findall(data))
# ['python one', 'python two', 'python three']
```

### 버보스와 주석의 예시
```python
email_pattern = re.compile(r"""
^                   # 문 자 열 의 시 작
[a-zA-Z0-9._%+-]+   # 사 용 자 명: 영 문 자 , 숫 자 , 특 수 문 자
@                   # @ 기 호
[a-zA-Z0-9.-]+      # 도 메 인 명: 영 문 자 , 숫 자 , 점 , 하 이 픈
\.                  # 점(.)
[a-zA-Z]{2,}        # 최 상 위 도 메 인: 영 문 자 2자 이 상
$                   # 문 자 열 의 끝
""", re.VERBOSE)
```

### r 스트링
- Raw string.
