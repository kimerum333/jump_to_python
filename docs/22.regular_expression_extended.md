# 문자열 소비 없는 메타문자
## |
- or 의 의미.

## ^
- 문자열의 시작을 의미.
- 멀티라인과 자주 함께 쓰임

## $
- ^의 반대. 문자열의 끝을 의미.

## \A
- 문자열의 시작을 의미. ^와 같은 의미지만, 멀티라인 옵션 위에서도 멀티라인 옵션이 없는 ^처럼 동작해서 문자열의 가장 처음만 인식한다.

## \Z
- \A 의 반대 버전. 나머지 속성은 같다.

## \b
- 단어 구분자.
- 보통 하나의 단어는 whitespace(띄어쓰기 문자) 에 의해 구분된다.
```python
p = re.compile(r'\bclass\b')
print(p.search('no class at all'))
# <re.Match object; span=(3, 8), match='class'>
print(p.search('the declassified algorithm'))
# None
```

## \B
- \B 의 반대.
- 띄어쓰기로 구분된게 아닌, 다른 문자와 자연스레 뒤섞인 문자를 찾아낼때 쓴다.
```python
p = re.compile(r'\Bclass\B')
print(p.search('no class at all'))
# None
print(p.search('the declassified algorithm'))
# <re.Match object; span=(6, 11), match='class'>
print(p.search('one subclass is'))
# None : 앞은 붙었지만, 뒤는 \B 를 만족하지 않으므로 None
```

# 그루핑
## 목적
- 여러 문자를 하나로 묶어서 반복 처리하기
- 매치된 문자열에서 원하는 부분만 추출하기
## 예시
- (ABC)+
- ABC 문자열이 반복되는지 조사하려는 상황.
```python
p = re.compile('(ABC)+')
m = p.search('ABCABCABC OK?')
print(m)
# <re.Match object; span=(0, 9), match='ABCABCABC'>
print(m.group())
# ABCABCABC
```

## 활용
- 매칭된 문자열에서 원하는 부분만 뽑아내기
```python
p = re.compile(r"\w+\s+\d+[-]\d+[-]\d+") # 문자 공백 숫자-숫자-숫자
m = p.search("park 010-1234-1234")

# 위 예시에서, 이름만 뽑아내고 싶다면 이름 영역을 그루핑 (괄호로 묶기) 한다.

p = re.compile(r"(\w+)\s+\d+[-]\d+[-]\d+") # (\w+) 로 묶은 모습
m = p.search("park 010-1234-1234")
print(m.group(1))
# park
```
### 그룹 인덱스
- group(0) = 매칭된 전체 문자열을 리턴
- group(1) = 첫번째 그룹을 리턴

### 중첩 그룹
```python
p = re.compile(r"(\w+)\s+((\d+)[-]\d+[-]\d+)") # 전화번호를 한번 그루핑하고, 010이 들어갈 가장 앞을 다시 그룹해 중첩 그루핑이 가능
m = p.search("park 010-1234-1234")
print(m.group(3))
# 010

# 내부로 들어갈수록 그룹번호가 올라간다. 증, 1번그룹은 이름, 2번그룹은 전화번호 전체, 3번그룹은 010
```

### 그룹에 이름 주기
- (\w+) → (?P<name>\w+)
예시
```python
p = re.compile(r"(?P<name>\w+)\s+((\d+)[-]\d+[-]\d+)")
m = p.search("park 010-1234-1234")
print(m.group("name"))
# park
```
```python
# 정규식 내부 재참조 예시
# 앞에 띄어쓰기가 있는 단어를 워드 블록으로 묶고, 공백 뒤 해당 워드가 반복되는 패턴을 찾는다. => 뭔가 특정 문자가 반복되는 것을 잡아낼 수 있음.
p = re.compile(r'(?P<word>\b\w+)\s+(?P=word)')
p.search('Paris in the the spring').group()
# 'the the'
```

# 전방 탐색
## 예시
```python
# 어떤 문자든 1개 이상이 나오고 그 뒤 콜론이 오는 패턴
p = re.compile(".+:")
m = p.search("http://google.com")
print(m.group())
# http:
# 만약 http: 는 매칭하고 싶은데, :는 필요 없고 http만 얻어내고 싶을 경우 전방 탐색이 활용된다.
```
## 종류
- 긍정형 전방 탐색 : 뒤에 ...가 오는지 확인하되, 실제로는 포함하지 않기(?=...)
- 부정형 전방 탐색 : 뒤에 ...가 오지 않는지 확인하되, 실제로는 포함하지 않기(?!...)

### 긍정형 전방 탐색의 예시
```python
p = re.compile(".+(?=:)") #(?=:)로 :을 긍정형 전방탐색한다.
m = p.search("http://google.com")
print(m.group())
# http
```
### 부정형 전방 탐색의 예시
```python
# .*[.].*$ 문자열 아무거나가 오고, dot 문자 후 문자열 아무거나가 오고 종료되는 파일명을 나타내는 정규표현식이다.
# .*[.](?!bat$|exe$).*$ 이런 식으로 처리하면, bat 파일이나 exe 파일을 제외 가능.
```

# Sub
- 정규식과 매칭되는 부분을 다른 문자열로 바꾼다.
## 예시
```python
p = re.compile('blue|white|red')
# sub의 첫 인자는 바꿀 문자열, 두번째 인수는 대상 문자열
p.sub('colour','blue socks and red shoes')
# colour socks and colour shoes

p.sub('colour','blue socks and red shoes', count=1)
# colour socks and red shoes
# 카운트 옵션을 줘서 처음 n회만 바꿀 수도 있다.
```
## 참조 구문
```python
p = re.compile(r"(?P<name>\w+)\s+(?P<phone>(\d+)[-]\d+[-]\d+)")
# 패턴의 그룹을 \g<그룹명> 으로 지정하면 sub 에서 해당 그룹명을 참조할 수 있다.
print(p.sub("\g<phone> \g<name>", "park 010-1234-1234"))
# 010-1234-1234 park
```

## 함수 넣기
```python
def hex_replace(match):
    value = int(match.group())
    return hex(value)

p = re.compile(r'\d+')

p.sub(hex_replace,'Call 65490 for printing, 49152 for user code.')
# 'Call 0xffd2 for printing, 0xc000 for user code.'
```

## greedy / non greedy
```python
s = '<html><head><title>Title</title>'
len(s)
# 32
print(re.match('<.*>', s).span())
# (0, 32)
print(re.match('<.*>', s).group())
# <html><head><title>Title</title>

print(re.match('<.*?>', s).group())
```
- non‑greedy 문자인 ?는 *?, +?, ??, {m,n}?와 같이 사용할 수 있다. 되도록 최소한으로 반복을 수행하도록 도와주는 역할을 한다.