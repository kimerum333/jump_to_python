# iterator
## 개요
- 반복자
- java 쓸때 쓰던, 한바퀴 돌면서 내용물 쭉 꺼내주는 그 객체
- next() 함수로 다음 데이터를 꺼내올 수 있으며,  다 꺼내오면 예외 발생.
- list 등의 객체를 iter() 함수로 이터레이터로 만들 수 있다.
```python
a = [1,2,3]
ia = iter(a)
# 이터레이터를 쓰는 가장 좋은 방법 : for문 돌리기
for i in a:
    print(i)
```

## 이터레이터의 작성
- __iter__ : 이터레이터 객체 자신을 반환하므로 중요.
- __next__ : 다음 값을 반환하며, 더이상 없으면 StopIteration 예외 발생

```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.position = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self.position >= len(self.data):
            raise StropIteration
        result = self.data(self.position)
        self.position += 1
        return result

if __name__ == "__main__":
    i = MyIterator([1,2,3])
    for item in i:
        print (item)
```

# Generator
- 이터레이터를 만드는 함수.
- __iter__ 와 __next__ 를 직접 구현하는것보다 쉽게 이터레이터를 만들 수 있다.
## 핵심 특징
- 일반 함수와 비슷하지만, return 대신 yield 를 사용
- yield 를 만나면 값을 반환하고 함수 실행을 일시 정지
- 재호출시 일시정지했던 시점부터 재동작

```python
def mygen():
    for num in range(1,1000):
        yield num * num
# 제네레이터의 인스턴스화
g = mygen()

# 제네레이터를 인자로 next()를 호출시 하나씩 꺼내진다.
print(next(g)) # 1
print(next(g)) # 2
print(next(g)) # 3
```
```python
# 이렇게 축약해서 써도 즉석 제너레이터가 만들어진다. 위와 완전 동일하게 동작.
# 마치 리스트 컴프리헨션 같은데, 이걸 제너레이터 표현식이라고 한다.
g = (num * num for num in range(1,1000))
```

## 활용례
- 필요한 때만 메모리에 올려서 사용할 수 있다. (lazy evaluation)
```python
import time
def longtime_job():
    print("job start")
    time.sleep(1)
    return "done"

# 제너레이터 표현식: 함수를 미리 실행하지 않고 필요할 때만 실행
list_job = (longtime_job() for i in range(5))

print(next(list_job)) # 첫 번째 값만 요청
```